Using Trajan's Algorithm

Find Bridges in a graph using Tarjan's Algorithm.
Before heading towards the approach understand which edge is termed as bridge. Suppose there exists a edge from u -> v, now after removal of this edge if v can't be reached by any other edges then u -> v edge is bridge. Our approach is based on this intuition, so take time and grasp it.

ALGORITHM: -

To implement this algorithm, we need the following data structures -

visited[ ] = to keep track of the visited vertices to implement DFS
disc[ ] = to keep track when for the first time that particular vertex is reached
low[ ] = to keep track of the lowest possible time by which we can reach that vertex 'other than parent' so that if edge from parent is removed can the particular node can be reached other than parent.
We will traverse the graph using DFS traversal but with slight modifications i.e. while traversing we will keep track of the parent node by which the particular node is reached because we will update the low[node] = min(low[all it's adjacent node except parent]) hence we need to keep track of the parent.

While traversing adjacent nodes let 'v' of a particular node let 'u', then 3 cases arise -

1. v is parent of u then, 

skip that iteration.
2. v is visited then,

update the low of u i.e. low[u] = min( low[u] , disc[v]) this arises when a node can be visited by more than one node, but low is to keep track of the lowest possible time so we will update it.
3. v is not visited then,

call the DFS to traverse ahead
now update the low[u] = min( low[u], low[v] ) as we know v can't be parent cause we have handled that case first.
now check if ( low[v] > disc[u] ) i.e. the lowest possible to time to reach 'v' is greater than 'u' this means we can't reach 'v' without 'u' so the edge   u -> v is a bridge.
class Solution {
public:
    int timer = 1;

    void dfs(int node, int parent, vector<vector<int>>& adj,
             vector<int>& tin, vector<int>& low, vector<vector<int>>& bridges, vector<int>& visited) {
        
        visited[node] = 1;
        tin[node] = low[node] = timer++;

        for (auto it : adj[node]) {
            if (it == parent) continue;
            if (!visited[it]) {
                dfs(it, node, adj, tin, low, bridges, visited);
                low[node] = min(low[node], low[it]);

                // Bridge condition
                if (low[it] > tin[node]) {
                    bridges.push_back({node, it});
                }
            } else {
                low[node] = min(low[node], tin[it]);
            }
        }
    }

    vector<vector<int>> criticalConnections(int n, vector<vector<int>>& connections) {
        vector<vector<int>> adj(n);
        for (auto& it : connections) {
            int u = it[0], v = it[1];
            adj[u].push_back(v);
            adj[v].push_back(u);
        }

        vector<vector<int>> bridges;
        vector<int> tin(n, -1), low(n, -1), visited(n, 0);

        for (int i = 0; i < n; i++) {
            if (!visited[i]) {
                dfs(i, -1, adj, tin, low, bridges, visited);
            }
        }

        return bridges;
    }
};
