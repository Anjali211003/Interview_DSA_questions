----------------BRUTE FORCE ----------------------
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        nums.sort()
        smallest = 1
        for num in nums:
            if num == smallest:
                smallest += 1
        return smallest


 --------------OPTIMIZED APPROACH USING CYCLIC SORT----------------------
Optimized O(n), O(1) Approach (Cyclic Indexing / Bucket Placement) 

Core Idea:
     We only care about numbers in the range [1, n] (where n = len(nums)).
     Place each number x in its correct index (x → nums[x-1]).
     Ignore negatives, zeros, and numbers > n.
     After rearrangement, the first index i where nums[i] != i+1 → return i+1.
     If all are correct → return n+1.

Algorithm Steps:

  1.Loop through the array.
  2.For each number x, while:
         1 <= x <= n
         nums[x-1] != x
         → swap nums[i] with nums[x-1].
  3.After rearranging:
        Scan from left → if nums[i] != i+1 → return i+1.
  4.If all match → return n+1.

Code:

class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        n = len(nums)
        # Step 1: Place numbers in correct index if possible
        for i in range(n):
            while 1 <= nums[i] <= n and nums[nums[i]-1] != nums[i]:
                nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1]
        # Step 2: Find first index where condition fails
        for i in range(n):
            if nums[i] != i + 1:
                return i + 1
        # Step 3: If all matched
        return n + 1
        
